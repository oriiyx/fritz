package definition_builder

import (
	"fmt"
	"strings"
	"time"

	"github.com/oriiyx/fritz/app/core/services/objects/definitions"
)

func (e *Builder) genAdapterCode(d *definitions.EntityDefinition) string {
	var code strings.Builder

	code.WriteString("// Code generated by fritz. DO NOT EDIT.\n")
	code.WriteString(fmt.Sprintf("// Created at: %s\n\n", time.Now().UTC().Format(time.RFC3339)))
	code.WriteString("package adapters\n\n")

	// Collect imports
	imports := map[string]bool{
		"context": true,
		"fmt":     true,
		// "encoding/json": false,
	}

	imports["github.com/jackc/pgx/v5/pgtype"] = true
	imports["github.com/oriiyx/fritz/database/generated"] = true

	code.WriteString("import (\n")
	for imp := range imports {
		if imp == "github.com/oriiyx/fritz/database/generated" {
			code.WriteString(fmt.Sprintf("\tdb \"%s\"\n", imp))
		} else {
			code.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
	}
	code.WriteString(")\n\n")

	// Generate the adapter struct
	entityName := d.Name
	code.WriteString(fmt.Sprintf("type %sAdapter struct {\n", entityName))
	code.WriteString("\tqueries *db.Queries\n")
	code.WriteString("}\n\n")

	code.WriteString(fmt.Sprintf("func New%sAdapter(queries *db.Queries) *%sAdapter {\n", entityName, entityName))
	code.WriteString(fmt.Sprintf("\treturn &%sAdapter{queries: queries}\n", entityName))
	code.WriteString("}\n\n")

	// Generate Create method
	code.WriteString(e.genAdapterCreate(d))
	code.WriteString("\n\n")

	// Generate Read method
	code.WriteString(e.genAdapterRead(d))
	code.WriteString("\n\n")

	// Generate Update method
	code.WriteString(e.genAdapterUpdate(d))
	code.WriteString("\n\n")

	// Generate Delete method
	code.WriteString(e.genAdapterDelete(d))

	// Generate init function to auto-register
	code.WriteString("\n\n")
	code.WriteString("func init() {\n")
	code.WriteString(fmt.Sprintf("\t// This will be called when queries are initialized\n"))
	code.WriteString("}\n\n")

	code.WriteString(fmt.Sprintf("// Register%sAdapter registers this adapter with the given queries\n", entityName))
	code.WriteString(fmt.Sprintf("func Register%sAdapter(queries *db.Queries) {\n", entityName))
	code.WriteString(fmt.Sprintf("\tRegister(\"%s\", New%sAdapter(queries))\n", d.ID, entityName))
	code.WriteString("}\n")

	return code.String()
}

func (e *Builder) genAdapterCreate(d *definitions.EntityDefinition) string {
	var code strings.Builder
	entityName := d.Name

	code.WriteString(fmt.Sprintf("func (a *%sAdapter) Create(ctx context.Context, entityID any, data map[string]interface{}) (interface{}, error) {\n", entityName))

	// Parse entityID
	code.WriteString("\t// Parse entityID\n")
	code.WriteString("\tvar eid pgtype.UUID\n")
	code.WriteString("\tswitch v := entityID.(type) {\n")
	code.WriteString("\tcase string:\n")
	code.WriteString("\t\tif err := eid.Scan(v); err != nil {\n")
	code.WriteString("\t\t\treturn nil, fmt.Errorf(\"invalid entity_id: %w\", err)\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\tcase pgtype.UUID:\n")
	code.WriteString("\t\teid = v\n")
	code.WriteString("\tdefault:\n")
	code.WriteString("\t\treturn nil, fmt.Errorf(\"entity_id must be string or pgtype.UUID, got %T\", entityID)\n")
	code.WriteString("\t}\n\n")

	// Build params
	code.WriteString(fmt.Sprintf("\tparams := db.Create%sParams{\n", entityName))
	code.WriteString("\t\tEntityID: eid,\n")

	for _, comp := range d.Layout.Components {
		fieldName := toPascalCase(comp.Name)
		code.WriteString(fmt.Sprintf("\t\t%s: ", fieldName))
		code.WriteString(e.genFieldConversion(comp, "data"))
		code.WriteString(",\n")
	}

	code.WriteString("\t}\n\n")
	code.WriteString(fmt.Sprintf("\treturn a.queries.Create%s(ctx, params)\n", entityName))
	code.WriteString("}\n")

	return code.String()
}

func (e *Builder) genAdapterRead(d *definitions.EntityDefinition) string {
	var code strings.Builder
	entityName := d.Name

	code.WriteString(fmt.Sprintf("func (a *%sAdapter) Read(ctx context.Context, id any) (interface{}, error) {\n", entityName))

	code.WriteString("\tvar uid pgtype.UUID\n")
	code.WriteString("\tswitch v := id.(type) {\n")
	code.WriteString("\tcase string:\n")
	code.WriteString("\t\tif err := uid.Scan(v); err != nil {\n")
	code.WriteString("\t\t\treturn nil, fmt.Errorf(\"invalid id: %w\", err)\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\tcase pgtype.UUID:\n")
	code.WriteString("\t\tuid = v\n")
	code.WriteString("\tdefault:\n")
	code.WriteString("\t\treturn nil, fmt.Errorf(\"id must be string or pgtype.UUID, got %T\", id)\n")
	code.WriteString("\t}\n\n")

	code.WriteString(fmt.Sprintf("\treturn a.queries.Get%sByID(ctx, uid)\n", entityName))
	code.WriteString("}\n")

	return code.String()
}

func (e *Builder) genAdapterUpdate(d *definitions.EntityDefinition) string {
	var code strings.Builder
	entityName := d.Name

	code.WriteString(fmt.Sprintf("func (a *%sAdapter) Update(ctx context.Context, id any, data map[string]interface{}) (interface{}, error) {\n", entityName))

	code.WriteString("\tvar uid pgtype.UUID\n")
	code.WriteString("\tswitch v := id.(type) {\n")
	code.WriteString("\tcase string:\n")
	code.WriteString("\t\tif err := uid.Scan(v); err != nil {\n")
	code.WriteString("\t\t\treturn nil, fmt.Errorf(\"invalid id: %w\", err)\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\tcase pgtype.UUID:\n")
	code.WriteString("\t\tuid = v\n")
	code.WriteString("\tdefault:\n")
	code.WriteString("\t\treturn nil, fmt.Errorf(\"id must be string or pgtype.UUID, got %T\", id)\n")
	code.WriteString("\t}\n\n")

	code.WriteString(fmt.Sprintf("\tparams := db.Update%sParams{\n", entityName))
	code.WriteString("\t\tEntityID: uid,\n")

	for _, comp := range d.Layout.Components {
		fieldName := toPascalCase(comp.Name)
		code.WriteString(fmt.Sprintf("\t\t%s: ", fieldName))
		code.WriteString(e.genFieldConversion(comp, "data"))
		code.WriteString(",\n")
	}

	code.WriteString("\t}\n\n")
	code.WriteString(fmt.Sprintf("\treturn a.queries.Update%s(ctx, params)\n", entityName))
	code.WriteString("}\n")

	return code.String()
}

func (e *Builder) genAdapterDelete(d *definitions.EntityDefinition) string {
	var code strings.Builder
	entityName := d.Name

	code.WriteString(fmt.Sprintf("func (a *%sAdapter) Delete(ctx context.Context, id any) error {\n", entityName))

	code.WriteString("\tvar uid pgtype.UUID\n")
	code.WriteString("\tswitch v := id.(type) {\n")
	code.WriteString("\tcase string:\n")
	code.WriteString("\t\tif err := uid.Scan(v); err != nil {\n")
	code.WriteString("\t\t\treturn fmt.Errorf(\"invalid id: %w\", err)\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\tcase pgtype.UUID:\n")
	code.WriteString("\t\tuid = v\n")
	code.WriteString("\tdefault:\n")
	code.WriteString("\t\treturn fmt.Errorf(\"id must be string or pgtype.UUID, got %T\", id)\n")
	code.WriteString("\t}\n\n")

	code.WriteString(fmt.Sprintf("\treturn a.queries.Delete%s(ctx, uid)\n", entityName))
	code.WriteString("}\n")

	return code.String()
}

// genFieldConversion generates the field conversion code for adapter methods
func (e *Builder) genFieldConversion(comp definitions.DataComponent, dataVar string) string {
	goType := comp.GetGoType()
	fieldName := comp.Name

	// Handle conversion based on type
	switch goType {
	// String types
	case "string":
		return fmt.Sprintf("mustGetString(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Text":
		return fmt.Sprintf("getPgText(%s, \"%s\")", dataVar, fieldName)

	// Integer types - NOT NULL
	case "int32":
		return fmt.Sprintf("mustGetInt32(%s, \"%s\")", dataVar, fieldName)

	case "int64":
		return fmt.Sprintf("mustGetInt64(%s, \"%s\")", dataVar, fieldName)

	case "int16":
		return fmt.Sprintf("mustGetInt16(%s, \"%s\")", dataVar, fieldName)

	// Integer types - NULLABLE (pgtype)
	case "pgtype.Int4":
		return fmt.Sprintf("getPgInt4(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Int8":
		return fmt.Sprintf("getPgInt8(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Int2":
		return fmt.Sprintf("getPgInt2(%s, \"%s\")", dataVar, fieldName)

	// Boolean types
	case "bool":
		return fmt.Sprintf("mustGetBool(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Bool":
		return fmt.Sprintf("getPgBool(%s, \"%s\")", dataVar, fieldName)

	// Date/Time types
	case "pgtype.Date":
		return fmt.Sprintf("getPgDate(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Timestamptz":
		return fmt.Sprintf("getPgTimestamp(%s, \"%s\")", dataVar, fieldName)

	default:
		return fmt.Sprintf("%s[\"%s\"]", dataVar, fieldName)
	}
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
