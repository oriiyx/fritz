package definition_builder

import (
	"fmt"
	"os/exec"
	"strings"
	"time"

	"github.com/oriiyx/fritz/app/core/services/objects/definitions"
)

const EntitiesTableQueriesFilePathTemplate = "database/fritz"
const EntitiesAdaptersFilePathTemplate = "app/core/services/entities/adapters"

func (e *Builder) CreateCrudOperations(tablename string, d *definitions.EntityDefinition) error {
	queriesName := fmt.Sprintf("queries_%s", d.ID)
	commentBlock := "-- Code generated by fritz. DO NOT EDIT.\n" +
		fmt.Sprintf("-- Created at: %s\n", time.Now().UTC().String())

	createStatement, err := e.genCreate(tablename, d)
	if err != nil {
		return err
	}

	editStatement, err := e.genEdit(tablename, d)
	if err != nil {
		return err
	}

	readStatement, err := e.genRead(tablename, d)
	if err != nil {
		return err
	}

	deleteStatement, err := e.genDelete(tablename, d)
	if err != nil {
		return err
	}

	sql := strings.Join([]string{commentBlock, createStatement, editStatement, readStatement, deleteStatement}, "\n\n")

	err = e.cw.WriteNewFile(sql, EntitiesTableQueriesFilePathTemplate, fmt.Sprintf("%s.sql", queriesName))
	if err != nil {
		return fmt.Errorf("failed to write CRUD queries file: %w", err)
	}

	e.logger.Info().
		Str("table", tablename).
		Str("entity_id", d.ID).
		Str("file", fmt.Sprintf("%s/%s.sql", EntitiesTableQueriesFilePathTemplate, queriesName)).
		Msg("Generated CRUD operations file")

	// Run sqlc generate
	cmd := exec.Command("sqlc", "generate")
	output, err := cmd.CombinedOutput()
	if err != nil {
		e.logger.Error().
			Err(err).
			Str("output", string(output)).
			Msg("SQLC generate failed")
		return fmt.Errorf("sqlc generate failed: %w - output: %s", err, string(output))
	}

	e.logger.Info().
		Str("entity_id", d.ID).
		Msg("SQLC generation completed successfully")

	// Now generate the adapter code that bridges JSON -> SQLC
	adapterCode := e.genAdapterCode(d)
	adapterFilename := e.CreateAdapterFileName(d)

	err = e.cw.WriteNewFile(adapterCode, "app/core/services/entities/adapters", adapterFilename)
	if err != nil {
		return fmt.Errorf("failed to write adapter file: %w", err)
	}

	e.logger.Info().
		Str("entity_id", d.ID).
		Str("file", fmt.Sprintf("app/core/services/entities/adapters/%s", adapterFilename)).
		Msg("Generated entity adapter")

	// Update the central loader file
	err = e.UpdateAdapterLoader(d)
	if err != nil {
		e.logger.Warn().Err(err).Msg("Failed to update adapter loader")
	}

	return nil
}

func (e *Builder) CreateAdapterFileName(d *definitions.EntityDefinition) string {
	return fmt.Sprintf("adapter_%s.go", d.ID)
}

func (e *Builder) UpdateAdapterLoader(d *definitions.EntityDefinition) error {
	entityDefinitions, err := e.LoadDefinitionsFromEntityFiles()
	if err != nil {
		return err
	}

	var code strings.Builder
	code.WriteString("// Code generated by fritz. DO NOT EDIT.\n\n")
	code.WriteString("package adapters\n\n")
	code.WriteString("import (\n")
	code.WriteString("\tdb \"github.com/oriiyx/fritz/database/generated\"\n")
	code.WriteString(")\n\n")
	code.WriteString("// LoadAll registers all entity adapters\n")
	code.WriteString("func LoadAll(queries *db.Queries) {\n")

	for _, def := range entityDefinitions {
		code.WriteString(fmt.Sprintf("\tRegister(\"%s\", New%sAdapter(queries))\n", def.ID, def.Name))
	}

	code.WriteString("}\n")

	return e.cw.WriteNewFile(code.String(), "app/core/services/entities/adapters", "loader.go")
}

func (e *Builder) genCreate(tablename string, d *definitions.EntityDefinition) (string, error) {
	queryName := fmt.Sprintf("Create%s", d.Name)
	sqlcStatement := fmt.Sprintf("-- name: %s :one", queryName)

	// Build column names and placeholders
	var columns []string
	var placeholders []string
	paramIndex := 1

	// entity_id is always required
	columns = append(columns, "entity_id")
	placeholders = append(placeholders, fmt.Sprintf("$%d", paramIndex))
	paramIndex++

	// Add each component column
	for _, component := range d.Layout.Components {
		columns = append(columns, component.Name)
		placeholders = append(placeholders, fmt.Sprintf("$%d", paramIndex))
		paramIndex++
	}

	sqlStatement := fmt.Sprintf(
		"INSERT INTO %s (%s)\nVALUES (%s)\nRETURNING *;",
		tablename,
		strings.Join(columns, ", "),
		strings.Join(placeholders, ", "),
	)

	sql := strings.Join([]string{sqlcStatement, sqlStatement}, "\n")
	return sql, nil
}

func (e *Builder) genEdit(tablename string, d *definitions.EntityDefinition) (string, error) {
	queryName := fmt.Sprintf("Update%s", d.Name)
	sqlcStatement := fmt.Sprintf("-- name: %s :one", queryName)

	// Build SET clauses
	var setClauses []string
	paramIndex := 1

	// Add each component column
	for _, component := range d.Layout.Components {
		setClauses = append(setClauses, fmt.Sprintf("%s = $%d", component.Name, paramIndex))
		paramIndex++
	}

	// Add updated_at
	setClauses = append(setClauses, "updated_at = NOW()")

	// ID is the last parameter
	idParam := paramIndex

	sqlStatement := fmt.Sprintf(
		"UPDATE %s\nSET %s\nWHERE entity_id = $%d\nRETURNING *;",
		tablename,
		strings.Join(setClauses, ", "),
		idParam,
	)

	sql := strings.Join([]string{sqlcStatement, sqlStatement}, "\n")
	return sql, nil
}

func (e *Builder) genRead(tablename string, d *definitions.EntityDefinition) (string, error) {
	queryName := fmt.Sprintf("Get%sByID", d.Name)
	sqlcStatement := fmt.Sprintf("-- name: %s :one", queryName)
	sqlStatement := fmt.Sprintf("SELECT * FROM %s WHERE entity_id = $1;", tablename)

	sql := strings.Join([]string{sqlcStatement, sqlStatement}, "\n")
	return sql, nil
}

func (e *Builder) genDelete(tablename string, d *definitions.EntityDefinition) (string, error) {
	queryName := fmt.Sprintf("Delete%s", d.Name)
	sqlcStatement := fmt.Sprintf("-- name: %s :exec", queryName)
	sqlStatement := fmt.Sprintf("DELETE FROM %s WHERE entity_id = $1;", tablename)

	sql := strings.Join([]string{sqlcStatement, sqlStatement}, "\n")
	return sql, nil
}

func (e *Builder) genAdapterCode(d *definitions.EntityDefinition) string {
	var code strings.Builder

	code.WriteString("// Code generated by fritz. DO NOT EDIT.\n")
	code.WriteString(fmt.Sprintf("// Created at: %s\n\n", time.Now().UTC().Format(time.RFC3339)))
	code.WriteString("package adapters\n\n")

	// Collect imports
	imports := map[string]bool{
		"context": true,
		"fmt":     true,
		// "encoding/json": false,
	}

	imports["github.com/jackc/pgx/v5/pgtype"] = true
	imports["github.com/oriiyx/fritz/database/generated"] = true

	code.WriteString("import (\n")
	for imp := range imports {
		if imp == "github.com/oriiyx/fritz/database/generated" {
			code.WriteString(fmt.Sprintf("\tdb \"%s\"\n", imp))
		} else {
			code.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
	}
	code.WriteString(")\n\n")

	// Generate the adapter struct
	entityName := d.Name
	code.WriteString(fmt.Sprintf("type %sAdapter struct {\n", entityName))
	code.WriteString("\tqueries *db.Queries\n")
	code.WriteString("}\n\n")

	code.WriteString(fmt.Sprintf("func New%sAdapter(queries *db.Queries) *%sAdapter {\n", entityName, entityName))
	code.WriteString(fmt.Sprintf("\treturn &%sAdapter{queries: queries}\n", entityName))
	code.WriteString("}\n\n")

	// Generate Create method
	code.WriteString(e.genAdapterCreate(d))
	code.WriteString("\n\n")

	// Generate Read method
	code.WriteString(e.genAdapterRead(d))
	code.WriteString("\n\n")

	// Generate Update method
	code.WriteString(e.genAdapterUpdate(d))
	code.WriteString("\n\n")

	// Generate Delete method
	code.WriteString(e.genAdapterDelete(d))

	// Generate init function to auto-register
	code.WriteString("\n\n")
	code.WriteString("func init() {\n")
	code.WriteString(fmt.Sprintf("\t// This will be called when queries are initialized\n"))
	code.WriteString("}\n\n")

	code.WriteString(fmt.Sprintf("// Register%sAdapter registers this adapter with the given queries\n", entityName))
	code.WriteString(fmt.Sprintf("func Register%sAdapter(queries *db.Queries) {\n", entityName))
	code.WriteString(fmt.Sprintf("\tRegister(\"%s\", New%sAdapter(queries))\n", d.ID, entityName))
	code.WriteString("}\n")

	return code.String()
}

func (e *Builder) genAdapterCreate(d *definitions.EntityDefinition) string {
	var code strings.Builder
	entityName := d.Name

	code.WriteString(fmt.Sprintf("func (a *%sAdapter) Create(ctx context.Context, entityID any, data map[string]interface{}) (interface{}, error) {\n", entityName))

	// Parse entityID
	code.WriteString("\t// Parse entityID\n")
	code.WriteString("\tvar eid pgtype.UUID\n")
	code.WriteString("\tswitch v := entityID.(type) {\n")
	code.WriteString("\tcase string:\n")
	code.WriteString("\t\tif err := eid.Scan(v); err != nil {\n")
	code.WriteString("\t\t\treturn nil, fmt.Errorf(\"invalid entity_id: %w\", err)\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\tcase pgtype.UUID:\n")
	code.WriteString("\t\teid = v\n")
	code.WriteString("\tdefault:\n")
	code.WriteString("\t\treturn nil, fmt.Errorf(\"entity_id must be string or pgtype.UUID, got %T\", entityID)\n")
	code.WriteString("\t}\n\n")

	// Build params
	code.WriteString(fmt.Sprintf("\tparams := db.Create%sParams{\n", entityName))
	code.WriteString("\t\tEntityID: eid,\n")

	for _, comp := range d.Layout.Components {
		fieldName := toPascalCase(comp.Name)
		code.WriteString(fmt.Sprintf("\t\t%s: ", fieldName))
		code.WriteString(e.genFieldConversion(comp, "data"))
		code.WriteString(",\n")
	}

	code.WriteString("\t}\n\n")
	code.WriteString(fmt.Sprintf("\treturn a.queries.Create%s(ctx, params)\n", entityName))
	code.WriteString("}\n")

	return code.String()
}

func (e *Builder) genAdapterRead(d *definitions.EntityDefinition) string {
	var code strings.Builder
	entityName := d.Name

	code.WriteString(fmt.Sprintf("func (a *%sAdapter) Read(ctx context.Context, id any) (interface{}, error) {\n", entityName))

	code.WriteString("\tvar uid pgtype.UUID\n")
	code.WriteString("\tswitch v := id.(type) {\n")
	code.WriteString("\tcase string:\n")
	code.WriteString("\t\tif err := uid.Scan(v); err != nil {\n")
	code.WriteString("\t\t\treturn nil, fmt.Errorf(\"invalid id: %w\", err)\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\tcase pgtype.UUID:\n")
	code.WriteString("\t\tuid = v\n")
	code.WriteString("\tdefault:\n")
	code.WriteString("\t\treturn nil, fmt.Errorf(\"id must be string or pgtype.UUID, got %T\", id)\n")
	code.WriteString("\t}\n\n")

	code.WriteString(fmt.Sprintf("\treturn a.queries.Get%sByID(ctx, uid)\n", entityName))
	code.WriteString("}\n")

	return code.String()
}

func (e *Builder) genAdapterUpdate(d *definitions.EntityDefinition) string {
	var code strings.Builder
	entityName := d.Name

	code.WriteString(fmt.Sprintf("func (a *%sAdapter) Update(ctx context.Context, id any, data map[string]interface{}) (interface{}, error) {\n", entityName))

	code.WriteString("\tvar uid pgtype.UUID\n")
	code.WriteString("\tswitch v := id.(type) {\n")
	code.WriteString("\tcase string:\n")
	code.WriteString("\t\tif err := uid.Scan(v); err != nil {\n")
	code.WriteString("\t\t\treturn nil, fmt.Errorf(\"invalid id: %w\", err)\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\tcase pgtype.UUID:\n")
	code.WriteString("\t\tuid = v\n")
	code.WriteString("\tdefault:\n")
	code.WriteString("\t\treturn nil, fmt.Errorf(\"id must be string or pgtype.UUID, got %T\", id)\n")
	code.WriteString("\t}\n\n")

	code.WriteString(fmt.Sprintf("\tparams := db.Update%sParams{\n", entityName))
	code.WriteString("\t\tEntityID: uid,\n")

	for _, comp := range d.Layout.Components {
		fieldName := toPascalCase(comp.Name)
		code.WriteString(fmt.Sprintf("\t\t%s: ", fieldName))
		code.WriteString(e.genFieldConversion(comp, "data"))
		code.WriteString(",\n")
	}

	code.WriteString("\t}\n\n")
	code.WriteString(fmt.Sprintf("\treturn a.queries.Update%s(ctx, params)\n", entityName))
	code.WriteString("}\n")

	return code.String()
}

func (e *Builder) genAdapterDelete(d *definitions.EntityDefinition) string {
	var code strings.Builder
	entityName := d.Name

	code.WriteString(fmt.Sprintf("func (a *%sAdapter) Delete(ctx context.Context, id any) error {\n", entityName))

	code.WriteString("\tvar uid pgtype.UUID\n")
	code.WriteString("\tswitch v := id.(type) {\n")
	code.WriteString("\tcase string:\n")
	code.WriteString("\t\tif err := uid.Scan(v); err != nil {\n")
	code.WriteString("\t\t\treturn fmt.Errorf(\"invalid id: %w\", err)\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\tcase pgtype.UUID:\n")
	code.WriteString("\t\tuid = v\n")
	code.WriteString("\tdefault:\n")
	code.WriteString("\t\treturn fmt.Errorf(\"id must be string or pgtype.UUID, got %T\", id)\n")
	code.WriteString("\t}\n\n")

	code.WriteString(fmt.Sprintf("\treturn a.queries.Delete%s(ctx, uid)\n", entityName))
	code.WriteString("}\n")

	return code.String()
}

// genFieldConversion generates the field conversion code for adapter methods
func (e *Builder) genFieldConversion(comp definitions.DataComponent, dataVar string) string {
	goType := comp.GetGoType()
	fieldName := comp.Name

	// Handle conversion based on type
	switch goType {
	// String types
	case "string":
		return fmt.Sprintf("mustGetString(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Text":
		return fmt.Sprintf("getPgText(%s, \"%s\")", dataVar, fieldName)

	// Integer types - NOT NULL
	case "int32":
		return fmt.Sprintf("mustGetInt32(%s, \"%s\")", dataVar, fieldName)

	case "int64":
		return fmt.Sprintf("mustGetInt64(%s, \"%s\")", dataVar, fieldName)

	case "int16":
		return fmt.Sprintf("mustGetInt16(%s, \"%s\")", dataVar, fieldName)

	// Integer types - NULLABLE (pgtype)
	case "pgtype.Int4":
		return fmt.Sprintf("getPgInt4(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Int8":
		return fmt.Sprintf("getPgInt8(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Int2":
		return fmt.Sprintf("getPgInt2(%s, \"%s\")", dataVar, fieldName)

	// Boolean types
	case "bool":
		return fmt.Sprintf("mustGetBool(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Bool":
		return fmt.Sprintf("getPgBool(%s, \"%s\")", dataVar, fieldName)

	// Date/Time types
	case "pgtype.Date":
		return fmt.Sprintf("getPgDate(%s, \"%s\")", dataVar, fieldName)

	case "pgtype.Timestamptz":
		return fmt.Sprintf("getPgTimestamp(%s, \"%s\")", dataVar, fieldName)

	default:
		return fmt.Sprintf("%s[\"%s\"]", dataVar, fieldName)
	}
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
