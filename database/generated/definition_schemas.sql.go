// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: definition_schemas.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDefinitionSchemas = `-- name: CountDefinitionSchemas :one
SELECT COUNT(*)
FROM definition_schemas
`

// noinspection SqlResolve
func (q *Queries) CountDefinitionSchemas(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDefinitionSchemas)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDefinitionSchema = `-- name: CreateDefinitionSchema :one
INSERT INTO definition_schemas (id, name, description, schema_json, schema_hash)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, description, schema_json, schema_hash, created_at, updated_at
`

type CreateDefinitionSchemaParams struct {
	ID          string      `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	SchemaJson  []byte      `json:"schema_json"`
	SchemaHash  string      `json:"schema_hash"`
}

// noinspection SqlResolve
func (q *Queries) CreateDefinitionSchema(ctx context.Context, arg CreateDefinitionSchemaParams) (DefinitionSchema, error) {
	row := q.db.QueryRow(ctx, createDefinitionSchema,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.SchemaJson,
		arg.SchemaHash,
	)
	var i DefinitionSchema
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.SchemaJson,
		&i.SchemaHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const definitionSchemaExists = `-- name: DefinitionSchemaExists :one
SELECT EXISTS(SELECT 1 FROM definition_schemas WHERE id = $1) as exists
`

// noinspection SqlResolve
func (q *Queries) DefinitionSchemaExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, definitionSchemaExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteDefinitionSchema = `-- name: DeleteDefinitionSchema :exec
DELETE
FROM definition_schemas
WHERE id = $1
`

// noinspection SqlResolve
func (q *Queries) DeleteDefinitionSchema(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteDefinitionSchema, id)
	return err
}

const getAllDefinitionSchemas = `-- name: GetAllDefinitionSchemas :many
SELECT id, name, description, schema_json, schema_hash, created_at, updated_at
FROM definition_schemas
ORDER BY name ASC
`

// noinspection SqlResolve
func (q *Queries) GetAllDefinitionSchemas(ctx context.Context) ([]DefinitionSchema, error) {
	rows, err := q.db.Query(ctx, getAllDefinitionSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DefinitionSchema{}
	for rows.Next() {
		var i DefinitionSchema
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.SchemaJson,
			&i.SchemaHash,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefinitionSchemaByID = `-- name: GetDefinitionSchemaByID :one
SELECT id, name, description, schema_json, schema_hash, created_at, updated_at
FROM definition_schemas
WHERE id = $1
`

// noinspection SqlResolve
func (q *Queries) GetDefinitionSchemaByID(ctx context.Context, id string) (DefinitionSchema, error) {
	row := q.db.QueryRow(ctx, getDefinitionSchemaByID, id)
	var i DefinitionSchema
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.SchemaJson,
		&i.SchemaHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDefinitionSchemaHash = `-- name: GetDefinitionSchemaHash :one
SELECT schema_hash
FROM definition_schemas
WHERE id = $1
`

// Get only the hash for quick comparison
// noinspection SqlResolve
func (q *Queries) GetDefinitionSchemaHash(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, getDefinitionSchemaHash, id)
	var schema_hash string
	err := row.Scan(&schema_hash)
	return schema_hash, err
}

const getDefinitionSchemasByUpdatedDate = `-- name: GetDefinitionSchemasByUpdatedDate :many
SELECT id, name, description, schema_json, schema_hash, created_at, updated_at
FROM definition_schemas
ORDER BY updated_at DESC
LIMIT $1 OFFSET $2
`

type GetDefinitionSchemasByUpdatedDateParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get schemas ordered by most recently updated
// noinspection SqlResolve
func (q *Queries) GetDefinitionSchemasByUpdatedDate(ctx context.Context, arg GetDefinitionSchemasByUpdatedDateParams) ([]DefinitionSchema, error) {
	rows, err := q.db.Query(ctx, getDefinitionSchemasByUpdatedDate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DefinitionSchema{}
	for rows.Next() {
		var i DefinitionSchema
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.SchemaJson,
			&i.SchemaHash,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefinitionSchemasWithDifferentHash = `-- name: GetDefinitionSchemasWithDifferentHash :many
SELECT id, name, schema_hash
FROM definition_schemas
WHERE id = ANY ($1::text[])
  AND schema_hash != ANY ($2::text[])
`

type GetDefinitionSchemasWithDifferentHashParams struct {
	Column1 []string `json:"column_1"`
	Column2 []string `json:"column_2"`
}

type GetDefinitionSchemasWithDifferentHashRow struct {
	ID         string `json:"id"`
	Name       string `json:"name"`
	SchemaHash string `json:"schema_hash"`
}

// Find all schemas where hash doesn't match (for bulk load operations)
// noinspection SqlResolve
func (q *Queries) GetDefinitionSchemasWithDifferentHash(ctx context.Context, arg GetDefinitionSchemasWithDifferentHashParams) ([]GetDefinitionSchemasWithDifferentHashRow, error) {
	rows, err := q.db.Query(ctx, getDefinitionSchemasWithDifferentHash, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDefinitionSchemasWithDifferentHashRow{}
	for rows.Next() {
		var i GetDefinitionSchemasWithDifferentHashRow
		if err := rows.Scan(&i.ID, &i.Name, &i.SchemaHash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDefinitionSchema = `-- name: UpdateDefinitionSchema :one
UPDATE definition_schemas
SET name        = $2,
    description = $3,
    schema_json = $4,
    schema_hash = $5,
    updated_at  = NOW()
WHERE id = $1
RETURNING id, name, description, schema_json, schema_hash, created_at, updated_at
`

type UpdateDefinitionSchemaParams struct {
	ID          string      `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	SchemaJson  []byte      `json:"schema_json"`
	SchemaHash  string      `json:"schema_hash"`
}

// noinspection SqlResolve
func (q *Queries) UpdateDefinitionSchema(ctx context.Context, arg UpdateDefinitionSchemaParams) (DefinitionSchema, error) {
	row := q.db.QueryRow(ctx, updateDefinitionSchema,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.SchemaJson,
		arg.SchemaHash,
	)
	var i DefinitionSchema
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.SchemaJson,
		&i.SchemaHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
