// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: entities.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEntity = `-- name: CreateEntity :one
INSERT INTO entities (entity_class,
                      parent_id,
                      o_key,
                      o_path,
                      o_type,
                      published,
                      created_by,
                      updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, entity_class, parent_id, o_key, o_path, o_type, published, created_at, updated_at, created_by, updated_by
`

type CreateEntityParams struct {
	EntityClass string      `json:"entity_class"`
	ParentID    pgtype.UUID `json:"parent_id"`
	OKey        string      `json:"o_key"`
	OPath       string      `json:"o_path"`
	OType       string      `json:"o_type"`
	Published   bool        `json:"published"`
	CreatedBy   pgtype.UUID `json:"created_by"`
	UpdatedBy   pgtype.UUID `json:"updated_by"`
}

// noinspection SqlResolve
func (q *Queries) CreateEntity(ctx context.Context, arg CreateEntityParams) (Entity, error) {
	row := q.db.QueryRow(ctx, createEntity,
		arg.EntityClass,
		arg.ParentID,
		arg.OKey,
		arg.OPath,
		arg.OType,
		arg.Published,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.EntityClass,
		&i.ParentID,
		&i.OKey,
		&i.OPath,
		&i.OType,
		&i.Published,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteEntity = `-- name: DeleteEntity :exec
DELETE
FROM entities
WHERE id = $1
`

// noinspection SqlResolve
func (q *Queries) DeleteEntity(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEntity, id)
	return err
}

const getEntityByID = `-- name: GetEntityByID :one
SELECT id, entity_class, parent_id, o_key, o_path, o_type, published, created_at, updated_at, created_by, updated_by
FROM entities
WHERE id = $1
`

// noinspection SqlResolve
func (q *Queries) GetEntityByID(ctx context.Context, id pgtype.UUID) (Entity, error) {
	row := q.db.QueryRow(ctx, getEntityByID, id)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.EntityClass,
		&i.ParentID,
		&i.OKey,
		&i.OPath,
		&i.OType,
		&i.Published,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getEntityByPath = `-- name: GetEntityByPath :one
SELECT id, entity_class, parent_id, o_key, o_path, o_type, published, created_at, updated_at, created_by, updated_by
FROM entities
WHERE o_path = $1
  AND o_key = $2
`

type GetEntityByPathParams struct {
	OPath string `json:"o_path"`
	OKey  string `json:"o_key"`
}

// noinspection SqlResolve
func (q *Queries) GetEntityByPath(ctx context.Context, arg GetEntityByPathParams) (Entity, error) {
	row := q.db.QueryRow(ctx, getEntityByPath, arg.OPath, arg.OKey)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.EntityClass,
		&i.ParentID,
		&i.OKey,
		&i.OPath,
		&i.OType,
		&i.Published,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getEntityChildren = `-- name: GetEntityChildren :many
SELECT e.id,
       e.entity_class,
       e.parent_id,
       e.o_key,
       e.o_path,
       e.o_type,
       e.published,
       e.created_at,
       e.updated_at,
       -- Subquery to check if this entity has children
       EXISTS(SELECT 1
              FROM entities c
              WHERE c.parent_id = e.id
              LIMIT 1)                                            as has_children,
       -- Count of children (useful for UI)
       (SELECT COUNT(*) FROM entities c WHERE c.parent_id = e.id) as children_count
FROM entities e
WHERE e.parent_id = $1
ORDER BY
    -- Folders first, then objects, then variants
    CASE e.o_type
        WHEN 'folder' THEN 1
        WHEN 'object' THEN 2
        WHEN 'variant' THEN 3
        END,
    e.o_key ASC
LIMIT $2 OFFSET $3
`

type GetEntityChildrenParams struct {
	ParentID pgtype.UUID `json:"parent_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type GetEntityChildrenRow struct {
	ID            pgtype.UUID        `json:"id"`
	EntityClass   string             `json:"entity_class"`
	ParentID      pgtype.UUID        `json:"parent_id"`
	OKey          string             `json:"o_key"`
	OPath         string             `json:"o_path"`
	OType         string             `json:"o_type"`
	Published     bool               `json:"published"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	HasChildren   bool               `json:"has_children"`
	ChildrenCount int64              `json:"children_count"`
}

// Get direct children of a parent entity with pagination
// noinspection SqlResolve
//
//	AND ($2::text IS NULL OR e.entity_class = $2) -- TODO - potential improvement - Optional class filter
//	AND ($3::text IS NULL OR e.o_type = $3)       -- TODO - potential improvement - Optional type filter
func (q *Queries) GetEntityChildren(ctx context.Context, arg GetEntityChildrenParams) ([]GetEntityChildrenRow, error) {
	rows, err := q.db.Query(ctx, getEntityChildren, arg.ParentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityChildrenRow{}
	for rows.Next() {
		var i GetEntityChildrenRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityClass,
			&i.ParentID,
			&i.OKey,
			&i.OPath,
			&i.OType,
			&i.Published,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HasChildren,
			&i.ChildrenCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityChildrenCount = `-- name: GetEntityChildrenCount :one
SELECT COUNT(*)
FROM entities e
WHERE e.parent_id = $1
`

// Get total count of children (for pagination metadata)
// noinspection SqlResolve
func (q *Queries) GetEntityChildrenCount(ctx context.Context, parentID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getEntityChildrenCount, parentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEntityPath = `-- name: GetEntityPath :many

WITH RECURSIVE entity_path AS (
    -- Start with the target entity
    SELECT id,
           parent_id,
           o_key,
           o_path,
           o_type,
           0 as depth
    FROM entities
    WHERE entities.id = $1

    UNION ALL

    -- Recursively get parents
    SELECT e.id,
           e.parent_id,
           e.o_key,
           e.o_path,
           e.o_type,
           ep.depth + 1
    FROM entities e
             INNER JOIN entity_path ep ON e.id = ep.parent_id)
SELECT id, parent_id, o_key, o_path, o_type, depth
FROM entity_path
ORDER BY depth DESC
`

type GetEntityPathRow struct {
	ID       pgtype.UUID `json:"id"`
	ParentID pgtype.UUID `json:"parent_id"`
	OKey     string      `json:"o_key"`
	OPath    string      `json:"o_path"`
	OType    string      `json:"o_type"`
	Depth    int32       `json:"depth"`
}

//	AND ($2::text IS NULL OR e.entity_class = $2) - todo
//	AND ($3::text IS NULL OR e.o_type = $3); - todo
//
// Get all ancestors from root to this entity (for breadcrumb)
// This is the recursive CTE approach
// noinspection SqlResolve
func (q *Queries) GetEntityPath(ctx context.Context, id pgtype.UUID) ([]GetEntityPathRow, error) {
	rows, err := q.db.Query(ctx, getEntityPath, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityPathRow{}
	for rows.Next() {
		var i GetEntityPathRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.OKey,
			&i.OPath,
			&i.OType,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEntity = `-- name: UpdateEntity :one
UPDATE entities
SET parent_id  = $1,
    o_key      = $2,
    o_path     = $3,
    published  = $4,
    updated_by = $5,
    updated_at = NOW()
WHERE id = $6
RETURNING id, entity_class, parent_id, o_key, o_path, o_type, published, created_at, updated_at, created_by, updated_by
`

type UpdateEntityParams struct {
	ParentID  pgtype.UUID `json:"parent_id"`
	OKey      string      `json:"o_key"`
	OPath     string      `json:"o_path"`
	Published bool        `json:"published"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
	ID        pgtype.UUID `json:"id"`
}

// noinspection SqlResolve
func (q *Queries) UpdateEntity(ctx context.Context, arg UpdateEntityParams) (Entity, error) {
	row := q.db.QueryRow(ctx, updateEntity,
		arg.ParentID,
		arg.OKey,
		arg.OPath,
		arg.Published,
		arg.UpdatedBy,
		arg.ID,
	)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.EntityClass,
		&i.ParentID,
		&i.OKey,
		&i.OPath,
		&i.OType,
		&i.Published,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}
